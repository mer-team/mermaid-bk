require('dotenv').config()
const {Song_Classification} = require('../models/index')
const {Log, Song} = require('../models/index')
const async = require('async')
const {io} =  require("../index")
var search = require('youtube-search');


//////////////////////////////////////////////////////////////
//Functions in test///////////////////////////////////////////
var ip, userId, request //Ip of the user 

async function saveLog(msg, id){
    await Log.create({
        message: msg,
        service: "song classification",
        song_id: id, 
        type: "info"
    }).then(log => {
        console.log("Log created")
    }).catch(e => {
        console.log(e)
    })
}
//Save the song to the database
function saveTheSong(songId){
    var opts = {
        key: 'AIzaSyDeZyEFcD3GYpQMF6Xgc8DyNvFmWnGdoLM'
      };
      
      search(`https://www.youtube.com/watch?v=${songId}`, opts, async function(err, results) {
        if(err) return console.log(err);

            //Keep the song in the database
            const song = await Song.create({
                external_id: results[0].id,
                link: results[0].link, 
                title: results[0].title,
                artist: results[0].channelTitle,
                duration: new Date(0, 0, 0, 0, 2, 20),//Default the api dont give this data
                year: new Date(results[0].publishedAt).getFullYear(),
                date: new Date(results[0].publishedAt),
                genre: "Salsa, Kuduro, Romance", //Default the api dont give this data
                description: results[0].description,
                thumbnailHQ: results[0].thumbnails.high.url, 
                thumbnailMQ: results[0].thumbnails.medium.url, 
                hits: 0,
                waveform: "dQw4w9WgXcQ.png",
                status: "queued",
                added_by_ip: ip,
                added_by_user: userId, 
                general_classification: "" 
            }).then(song => {
                console.log("Song saved")
            }).catch(e => {
                console.log(e)
            })
      });
}

//See if the user has 

//Update the state of the song 
async function updateStateSong(status, songId){
    await Song.update({ 
        status: status
    }, { 
        where: { external_id: songId} 
    });
}

//Update the classifitication of the song
async function updateProcessed(emotion, songId){
    await Song.update({ 
        status: "processed", 
        general_classification: emotion
    }, { 
        where: { external_id: songId} 
    });
}
///////////////////////////////////////////////////7777777////
//////////////////////////////////////////////////////////////


//Here is the list of classification of the songs 
const classificationQueue = async.queue(async (song, callback) => {
    //To which id send the updates 
    const songSocket = request.connectedSong[song];
    
    try {
        updateStateSong("processing", song)
        //////////////////////////////////////////////////////////////////////////
        //Here we want to send the song we want to classify to the dummy service//
        //////////////////////////////////////////////////////////////////////////
        
        const delay = Math.floor(Math.random() * 10000)
        //Simulating the classification of the songs (temporary)
        setTimeout(async () => {
            if(songSocket){
                request.io.emit('progress', {
                    progress: 10, 
                    song_id: `${song}`, 
                    state: "Song Received"
                });

                await saveLog("Song Received")
            }
        }, delay);

        setTimeout(async () => {
            if(songSocket){
                request.io.emit('progress', {
                    progress: 30, 
                    song_id: `${song}`, 
                    state: "Video Dowloaded"
                });
                await saveLog("Video Dowloaded")
            }
            
        }, delay);

        setTimeout(async () => {
            if(songSocket){
                request.io.emit('progress', {
                    progress: 50, 
                    song_id: `${song}`, 
                    state: "Audio Channel exctracted from audio"
                });
                await saveLog("Audio Channel exctracted from audio")
            }
            
        }, delay);

        setTimeout(async () => {
            if(songSocket){
                request.io.emit('progress', {
                    progress: 60, 
                    song_id: `${song}`, 
                    state: "Features Extracted"
                });
                await saveLog("Features Extracted")
            }
            
        }, delay);

        setTimeout(async () => {
            if(songSocket){
                request.io.emit('progress', {
                    progress: 80, 
                    song_id: `${song}`, 
                    state: "Classification in process"
                });
                await saveLog("Classification in process")
            }
            
        }, delay);

        setTimeout(async () => {
            if(songSocket){
                request.io.emit('progress', {
                    progress: 100, 
                    song_id: `${song}`, 
                    state: "Classification finished"
                });
                await saveLog("Classification finished")
            }
            const emotions = ["Happy", "Sad", "Calm", "Tense"]
            var  rnd = Math.floor(Math.random() * emotions.length)
            const emotion = emotions[rnd]
            updateProcessed(emotion, song)
            
        }, delay);
    } catch (error) {
        updateStateSong("error", song)
        console.error("Error")
        callback(error)   
    }
}, 1) //This one means that we only accept one song at time and the others have to wait to be added to the classification queue 


function startClassification(song){
    saveTheSong(song)
    //Push the song to the queue 
    classificationQueue.push(song, (error) => {
        if(error){  
            console.error(error)
        }else{
            console.log("The song was classified")
        }
    })
}

module.exports = {

    //Get the Song classifications given the song_id
    async index(req, res){
        try{
            const { id } = req.headers
            console.log(id)
            const classifications = await Song_Classification.findAll({
                where: {
                    song_id: id
                }
            })
           return res.status(200).json(classifications)
        }catch(e){
            console.log(e)
        }
    }, 

    async classify(req, res){
        try {
            //Here we receive the external link of the song we want to classify (external id : means the id of the video on youtube)
            const { external_id, user_id } = req.params
            ip = req.clientIp
            request = req
            userId = user_id
            startClassification(external_id)
            //Simulating the classification and creating random logs to send to the frontend
            return res.status(200).json("The song was added to the queue")
        } catch (error) {
            console.log(error)
        }
    }, 

}